package com.huawei.od;

import java.util.concurrent.Executors;

/**
 * 题目描述
 * 在第一人称射击游戏中，玩家通过键盘的A S D W四个按键控制游戏人物分别向左、向后、向右、向前进行
 * 移动，从而完成走位。
 * 假设玩家每按动一次键盘，游戏任务会向某个方向移动一步，如果玩家在操作一定次数的键盘并且各个方向的步
 * 数相同时，此时游戏任务必定会回到原点，则称此次走位为完美走位。
 * 现给定玩家的走位(例如:ASDA)，请通过更换其中一段连续走位的方式使得原走位能够变成一个完美走位。其
 * 中待更换的连续走位可以是相同长度的任何走位。
 * 请返回待更换的连续走位的最小可能长度。
 * 如果原走位本身是一个完美走位，则返回0。
 * 输入描述
 * 输入为由键盘字母表示的走位s，例如:ASDA
 * 输出描述
 * 输出为待更换的连续走位的最小可能长度。
 * 用例
 * 输入
 * WASDAASD
 * 输出
 * 7
 * 说明
 * 将第二个A替换为W，即可得到完美走位
 * 输入
 * AAAA
 * 输出
 * 3
 * 说明
 * 将其中三个连续的A替换为WSD，即可得到完
 * 美走位
 *
 * 题目解析
 * 题目要求，保持WASD字母个数平衡，即相等，如果不相等，可以从字符串中选取一段连续子串替换，来让字符
 * 串平衡。
 * 比如:WWWWAAAASSSS
 * 字符串长度12WASD平衡的话，则每个字母个数应该是3个，而现在WAS各有4个，也就是说各超了1个。
 * 因此我们应该从字符串中，选取一段包含1个W，1个A，1个S的子串，来替换为D。
 * WWWWAAAASSSS
 * WWWWAAAASSSS
 * WWWWAAAASSSS
 * .......
 * WWWWAAAASSSS
 * 而符合这种要求的子串可能很多，我们需要找出其中最短的，即WAAAAS.
 * 本题其实就是求最小覆盖子串，同LeetCode-76最小覆盖子串 伏城之外的博客-CSDN博客
 */
public class Wmzw {

    public static void main(String[] args) {
    }


}
